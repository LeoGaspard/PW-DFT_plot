import numpy as np
import os
import matplotlib.pyplot as plt 
import matplotlib as mpl
import sys
from time import sleep

np.set_printoptions(threshold=sys.maxsize)

try:
    try:
        shell = get_ipython().__class__.__name__
        #Â Check for a jupyter notebook
        if shell == 'ZMQInteractiveShell':
            TERMINAL_COLUMNS =  114
        else:
            # Nice formatting
            TERMINAL_COLUMNS = min(150, os.get_terminal_size().columns)
    except NameError:
        TERMINAL_COLUMNS = min(150, os.get_terminal_size().columns)
except OSError :
    TERMINAL_COLUMNS = 150

A_TO_BOHR = 1.8897259886

class RespackData:
    """
        A class that stores and manipulates the output data generated by RESPACK

        Attributes
        ----------
            basis                    : list of str
                The name of the Wannier functions
            nW                       : int
                The number of Wannier functions
            spread                   : np.array of floats , shape (nW)
                The spread of each Wannier function
            ReciprocalLatticeVectors : np.array of floats , shape (3,3)
                The reciprocal lattice vectors in angstrom^{-1}
            LatticeVectors           : np.array of floats , shape (3,3)
                The lattice vectors in angstrom
            nkb                      : np.array of int , shape (3)
                The number of k-points along b1, b2 and b3
            nA                       : np.array of int , shape (3)
                The number of R vectors along a1, a2 and a3
            nR                       : int
                The total number of R vectors
            WannierCenters           : np.array of floats , shape (nW, 3)
                The positions (x, y, z) of the centers of the Wannier functions
            R                        : np.array of int , shape (nR, 3)
                The coordinates of each R vectors (in a1, a2, a3 basis)
            W                        : np.array of floats, shape (nR)
                The weight of each R vector
            ModelHamiltonian         : np.array of complex , shape (nR, nW, nW)
                For each R vector, the model Hamiltonian in the Wannier basis
            tvsR                     : np.array of floats , shape (nW, nW, nR, 2) 
                For each couple ia, ib of wannier and for each R, the distance and value of hopping


          ++IF *chiqw.out file exists

            nQ                       : int
                The number of Q points
            nFreq                    : int
                The number of frequencies computed
            freqGrid                 : np.array of floats
                The frequency grid used

          ++IF *w3d.out file exists
            
            calcW                    : float
                The frequency at which W is calculated
            Wmat                     : np.array of complex, shape (nR, nW, nW)
                The value of the screened interaction for each couple ia, ib of wannier at all R vectors
            Wmat                     : np.array of complex, shape (nR, nW, nW)
                The value of the unscreened interaction for each couple ia, ib of wannier at all R vectors
            WvsR                     : np.array of floats , shape (nW, nW, nR, 2) 
                For each couple ia, ib of wannier and for each R, the distance and value of W

          ++IF *j3d.out file exists

            jR                       : np.array of int, shape (6)
                The min/max value of the vector R computed along a1, a2, a3
            calcw_j                  : float
                The value of the frequency at which J is calculated
            nJR                      : int
                The total number of R vectors computed
            JR                       : np.array of int, shape (nJR, 3)
                The coordinates of each R vector (in a1, a2, a3 basis)
            Xmat                     : np.array of complex, shape(nJR, nW, nW)
                The value of the unsreened interaction X for each couple ia, ib of wannier at all JR vectors
            Jmat                     : np.array of complex, shape(nJR, nW, nW)
                The value of the sreened interaction J for each couple ia, ib of wannier at all JR vectors


        Methods
        -------
            __init__(baseDir, basis) 
                Initializes the class
            print_parameters()      
                Prints the parameters of the RESPACK calculation
            print_ham(R, orb='all', imag=False, abc_to_cart=[[1,0,0],[0,1,0],[0,0,1]] 
                Prints the hamiltonian for a given R vector
            plot_hoppint(ax, hoppings, **kwargs)
                Plots the hoppings of the system
            interpolate_bands(kpts, **kwargs)
                Interpolates the band structure using the Wannier hamiltonian
            print_W(R, orb='all', imag=False, abc_to_cart=[[1,0,0],[0,1,0],[0,0,1]] 
                Prints the W matrix for a given R vector
            print_J(R, orb='all', imag=False, abc_to_cart=[[1,0,0],[0,1,0],[0,0,1]] 
                Prints the J matrix for a given R vector
            print_X(R, orb='all', imag=False, abc_to_cart=[[1,0,0],[0,1,0],[0,0,1]] 
                Prints the X matrix for a given R vector
            print_V(R, orb='all', imag=False, abc_to_cart=[[1,0,0],[0,1,0],[0,0,1]] 
                Prints the V matrix for a given R vector
            get_W(R, orb1, orb2, imag=False, abc_to_cart=[[1,0,0],[0,1,0],[0,0,1]]
                Returns the value of W between orb1 and orb2 at a given R vector
            get_spread(orb)
                Returns the spread of a given orbital
            __search_R_min(R)
                Returns the R vector corresponding to the minimum distance from 0 0 0
    """
    def __init__(self, baseDir, basis):
        """
            Parameters
            ----------
            baseDir : str
                The basis directory containing all the RESPACK output files.
                The wannier output file must have the name *.wannier.out
                The chiqw output file must have the name   *.chiqw.out
                The w3d output file must have the name     *.w3d.out
                The j3d output file must have the name     *.j3d.out
                The output directories dir-* must be in this directory
                ONLY ONE out FILE IN THIS DIRECTORY AND SUBDIRECTORIES IS ACCEPTED
            basis   : list of str
                A list of the names of the Wannier functions in the same order as in RESPACK
        """
        self.basis = basis

        # Finding the Respack Wannier file 
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('wannier.out')]

        if len(f) == 0:
            print("No RESPACK Wannier output file found")
            exit()
        if len(f) > 1:
            print("More than one RESPACK Wannier output file found : ")
            for i in f:
                print(i)
            exit()

        # Reading the data of the .wannier.out file
        with open(f[0]) as f:
            sprd = False
            data = f.readlines()
            for i in range(len(data)):
                if "N_WANNIER" in data[i]:
                    self.nW = int(data[i].split("=")[-1][:-2])
                    if self.nW != len(self.basis):
                        print("Wrong basis, basis of size {:2.0f} was given but found {:2.0f} wannier functions".format(len(basis), self.nW))
                    self.spread = np.zeros(self.nW, dtype=float)
                elif "RECIPROCAL LATTICE VECTOR" in data[i]:
                    self.ReciprocalLatticeVectors = np.asarray([data[i+3].split(),data[i+4].split(),data[i+5].split()], dtype=float)
                    self.ReciprocalLatticeVectors *= A_TO_BOHR
                    i += 4
                elif "LATTICE VECTOR" in data[i]:
                    self.LatticeVectors = np.asarray([data[i+3].split(),data[i+4].split(),data[i+5].split()], dtype=float)
                    self.LatticeVectors /= A_TO_BOHR
                    i += 4
                elif 'nkb1,nkb2,nkb3,NTK' in data[i]:
                    self.nkb = np.array([data[i].split()[1], data[i].split()[2], data[i].split()[3]], dtype=int)
                    self.nA = np.array([data[i+1].split()[1], data[i+1].split()[2], data[i+1].split()[3]], dtype=int)
                    i += 1
                    self.nR = ( 2*self.nA[0]+1 ) * ( 2*self.nA[1]+1 ) * ( 2*self.nA[2]+1 )
                elif 'SPREAD HAS ALREADY CONVERGED IN INITIAL STEP' in data[i]:
                    sprd = True
                    j = i- (3+self.nW)
                    for k in range(self.nW):
                        self.spread[k] = float(data[j+k].split()[1]) / (A_TO_BOHR*A_TO_BOHR) 
            if sprd == False:
                m = max(loc for loc, val in enumerate(data) if "ILS" in val)
                for i in range(self.nW):
                    self.spread[i] = float(data[m+i+1].split()[1]) / (A_TO_BOHR*A_TO_BOHR)

        # Reading the positions of the Wannier
        with open(baseDir+"/dir-wan/dat.wan-center") as f:
            self.WannierCenters = np.zeros((self.nW, 3), dtype=float)
            data = f.readlines()
            M = np.linalg.inv(self.LatticeVectors)
            for i in range(2,len(data)):
                R = np.asarray(data[i].split(), dtype=float) / A_TO_BOHR
                R = np.dot(np.transpose(M),R)
                self.WannierCenters[i-2,:] = R

        # Loading the Hamiltonian 
        with open(baseDir+"/dir-wan/dat.h_mat_r") as f:
            self.ModelHamiltonian = np.zeros((self.nR, self.nW, self.nW), dtype = complex)
            self.R = np.zeros((self.nR, 3), dtype=int)
            self.W = np.ones(self.nR, dtype=float)
            f.readline()
            f.readline()
            f.readline()
            for iR in range(self.nR):
                Rl = f.readline().split()
                Rl = [int(i) for i in Rl]
                self.R[iR] = Rl

                if abs(Rl[0])==self.nA[0] and self.nkb[0]%2 == 0 and self.nA[0] != 0:
                    self.W[iR] *= 0.5
                if abs(Rl[1])==self.nA[1] and self.nkb[1]%2 == 0 and self.nA[1] != 0:
                    self.W[iR] *= 0.5
                if abs(Rl[2])==self.nA[2] and self.nkb[2]%2 == 0 and self.nA[2] != 0:
                    self.W[iR] *= 0.5

                for ia in range(self.nW):
                    for ib in range(self.nW):
                        l = f.readline().split()
                        a = int(l[0])-1
                        b = int(l[1])-1
                        val = complex(float(l[2]), float(l[3]))
                        self.ModelHamiltonian[iR, a, b] = val
                f.readline()
            self.tvsR = np.zeros( (self.nW, self.nW, self.nR, 2) , dtype=float ) 
            for ia in range(self.nW):
                for ib in range(self.nW):
                    for iR in range(self.nR):
                        R = self.__search_R_min(self.R[iR])
                        Ra = self.WannierCenters[ia]
                        Rb = R + self.WannierCenters[ib]
                        d = np.linalg.norm( np.matmul( self.LatticeVectors.transpose(), Ra-Rb ) )
                        self.tvsR[ia, ib, iR, 0] = d
                        self.tvsR[ia, ib, iR, 1] = self.ModelHamiltonian[iR, ia, ib].real

        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('chiqw.out')]
        if len(f) > 1:
            print("More than 1 chiqw output file found :")
            for i in f:
                print(i)
            exit()
        elif len(f) == 1:
            with open(f[0]) as f:
                data = f.readlines()
                for i in data:
                    if "Nq_irr" in i:
                        self.nQ = int(i.split()[1])
            with open(baseDir+"/dir-eps/dat.wgrid") as f:
                data = f.readlines()
                head = data.pop(0)
                self.nFreq = int(head)
                data = [i.split() for i in data]
                data = np.asarray(data, dtype=float)
                self.freqGrid = data[:,0]
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('w3d.out')]
        if len(f) > 1:
            print("More than 1 w3d output file found :")
            for i in f:
                print(i)
            exit()
        elif len(f) == 1:
            with open(f[0]) as f:
                data = f.readlines()
                for i in data:
                    if "CALC_IFREQ" in i:
                        self.calcW = self.freqGrid[ int(i.split()[-1][:-1]) - 1 ]
            with open(baseDir+"/dir-intW/dat.Wmat") as f:
                self.Wmat = np.zeros( (self.nR, self.nW, self.nW) , dtype = complex)
                f.readline()
                f.readline()
                f.readline()
                for iR in range(self.nR):
                    Rl = f.readline().split()
                    Rl = np.array([int(i) for i in Rl])
                    if np.linalg.norm( Rl - self.R[iR] ) > 1e-10:
                        print("Error, mismatch between R vectors from dat.h_mat_r and dat.Wmat :")
                        print("In dat.h_mat_r, R[{:3.0f}] = ({:+3.0f}, {:+3.0f}, {:+3.0f})".format(iR, self.R[iR][0], self.R[iR][1], self.R[iR][2]))
                        print("In dat.Wmat   , R[{:3.0f}] = ({:+3.0f}, {:+3.0f}, {:+3.0f})".format(iR, Rl[0], Rl[1], Rl[2]))
                        exit()

                    for ia in range(self.nW):
                        for ib in range(self.nW):
                            l = f.readline().split()
                            a = int(l[0])-1
                            b = int(l[1])-1
                            val = complex(float(l[2]), float(l[3]))
                            self.Wmat[iR, a, b] = val
                    f.readline()
            with open(baseDir+"/dir-intW/dat.Vmat") as f:
                self.Vmat = np.zeros( (self.nR, self.nW, self.nW) , dtype = complex)
                f.readline()
                f.readline()
                f.readline()
                for iR in range(self.nR):
                    Rl = f.readline().split()
                    Rl = np.array([int(i) for i in Rl])
                    if np.linalg.norm( Rl - self.R[iR] ) > 1e-10:
                        print("Error, mismatch between R vectors from dat.h_mat_r and dat.Vmat :")
                        print("In dat.h_mat_r, R[{:3.0f}] = ({:+3.0f}, {:+3.0f}, {:+3.0f})".format(iR, self.R[iR][0], self.R[iR][1], self.R[iR][2]))
                        print("In dat.Vmat   , R[{:3.0f}] = ({:+3.0f}, {:+3.0f}, {:+3.0f})".format(iR, Rl[0], Rl[1], Rl[2]))
                        exit()

                    for ia in range(self.nW):
                        for ib in range(self.nW):
                            l = f.readline().split()
                            a = int(l[0])-1
                            b = int(l[1])-1
                            val = complex(float(l[2]), float(l[3]))
                            self.Vmat[iR, a, b] = val
                    f.readline()
            self.WvsR = np.zeros((self.nW, self.nW, self.nR, 2))
            for ia in range(self.nW):
                for ib in range(self.nW):
                    for iR in range(self.nR):
                        R = self.__search_R_min(self.R[iR])
                        Ra = self.WannierCenters[ia]
                        Rb = R + self.WannierCenters[ib]
                        d = np.linalg.norm( np.matmul( self.LatticeVectors.transpose(), Ra-Rb ) )
                        self.WvsR[ia, ib, iR, 0] = d
                        self.WvsR[ia, ib, iR, 1] = self.Wmat[iR, ia, ib].real
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('j3d.out')]
        if len(f) > 1:
            print("More than 1 j3d output file found :")
            for i in f:
                print(i)
            exit()
        elif len(f) == 1:
            with open(f[0]) as f:
                data = f.readlines()
                self.jR = np.array([0, 0, 0, 0, 0, 0], dtype=int)
                for i in data:
                    if 'CALC_IFREQ' in i:
                        self.calcW_j = self.freqGrid[ int(i.split()[-1][:-1]) - 1 ]
                    if 'IX_INTJ_MIN' in i:
                        self.jR[0] = int(i.split()[-1][:-1])
                    if 'IX_INTJ_MAX' in i:
                        self.jR[1] = int(i.split()[-1][:-1])
                    if 'IY_INTJ_MIN' in i:
                        self.jR[2] = int(i.split()[-1][:-1])
                    if 'IY_INTJ_MAX' in i:
                        self.jR[3] = int(i.split()[-1][:-1])
                    if 'IZ_INTJ_MIN' in i:
                        self.jR[4] = int(i.split()[-1][:-1])
                    if 'IZ_INTJ_MAX' in i:
                        self.jR[5] = int(i.split()[-1])
                self.nJR =  ( 1 + self.jR[1] - self.jR[0] ) * ( 1 + self.jR[3] - self.jR[2] ) * ( 1 + self.jR[5] - self.jR[4] )
            with open(baseDir+"/dir-intJ/dat.Jmat") as f:
                self.Jmat = np.zeros( (self.nJR, self.nW, self.nW) , dtype=complex)
                self.JR   = np.zeros( (self.nJR, 3) , dtype = int)
                f.readline()
                f.readline()
                f.readline()
                for iR in range(self.nJR):
                    R = np.asarray( f.readline().split() , dtype=int)
                    self.JR[iR, :] = R[:]
                    for ia in range(self.nW):
                        for ib in range(self.nW):
                            l = f.readline().split()
                            a = int(l[0]) - 1
                            b = int(l[1]) - 1
                            val = complex(float(l[2]), float(l[3]))
                            self.Jmat[iR, a, b] = val
                    f.readline()
            with open(baseDir+"/dir-intJ/dat.Xmat") as f:
                self.Xmat = np.zeros( (self.nJR, self.nW, self.nW) , dtype=complex)
                f.readline()
                f.readline()
                f.readline()
                for iR in range(self.nJR):
                    R = np.asarray( f.readline().split() , dtype=int)

                    if np.linalg.norm( R - self.JR[iR] ) > 1e-10:
                        print("Error, mismatch between R vectors from dat.Jmat and dat.Xmat :")
                        print("In dat.Jmat   , R[{:3.0f}] = ({:+3.0f}, {:+3.0f}, {:+3.0f})".format(iR, self.JR[iR][0], self.JR[iR][1], self.JR[iR][2]))
                        print("In dat.Xmat   , R[{:3.0f}] = ({:+3.0f}, {:+3.0f}, {:+3.0f})".format(iR, R[0], R[1], R[2]))
                        exit()
                    for ia in range(self.nW):
                        for ib in range(self.nW):
                            l = f.readline().split()
                            a = int(l[0])-1
                            b = int(l[1])-1
                            val = complex(float(l[2]), float(l[3]))
                            self.Wmat[iR, a, b] = val
                    f.readline()
    def print_parameters(self):
        """
            Prints the parameters of the RESPACK calculations and some computed results
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("PARAMETERS OF THE RESPACK CALCULATION"))
        print("="*TERMINAL_COLUMNS)
        print("\t\tMonkhorst pack grid used for SCF calculation  : {:2.0f} x {:2.0f} x {:2.0f}".format(self.nkb[0], self.nkb[1], self.nkb[2]))
        print("\t\tNumber of Wannier functions                   : {:4.0f}".format(self.nW))
        print("\t\tNumber of R vectors                           : {:4.0f}".format(self.nR))
        print("\t\tLattice vectors (angstrom)                    :")
        print("\t\t\t{:15.11f}  {:15.11f}  {:15.11f}\n\t\t\t{:15.11f}  {:15.11f}  {:15.11f}\n\t\t\t{:15.11f}  {:15.11f}  {:15.11f}".format(self.LatticeVectors[0,0],
                    self.LatticeVectors[0,1],self.LatticeVectors[0,2],self.LatticeVectors[1,0],
                    self.LatticeVectors[1,1],self.LatticeVectors[1,2],self.LatticeVectors[2,0],
                    self.LatticeVectors[2,1],self.LatticeVectors[2,2]))
        print("\t\tReciprocal lattice vectors   (angstrom^{-1})  :")
        print("\t\t\t{:15.11f}  {:15.11f}  {:15.11f}\n\t\t\t{:15.11f}  {:15.11f}  {:15.11f}\n\t\t\t{:15.11f}  {:15.11f}  {:15.11f}".format(self.ReciprocalLatticeVectors[0,0],
                    self.ReciprocalLatticeVectors[0,1],self.ReciprocalLatticeVectors[0,2],self.ReciprocalLatticeVectors[1,0],
                    self.ReciprocalLatticeVectors[1,1],self.ReciprocalLatticeVectors[1,2],self.ReciprocalLatticeVectors[2,0],
                    self.ReciprocalLatticeVectors[2,1],self.ReciprocalLatticeVectors[2,2]))
        print("\t\tWannier functions spread                      :")
        for i in range(self.nW):
            print("\t\t\t{:10s} : {:15.11f} (angstrom^2)".format(self.basis[i], self.spread[i]))
        print("\t\tWannier functions fractional coordinates      :")
        for i in range(self.nW):
            print("\t\t\t{:10s} : {:+15.11f} {:+15.11f} {:+15.11f}".format(self.basis[i], self.WannierCenters[i,0], self.WannierCenters[i,1], self.WannierCenters[i,2]))
        if hasattr(self, "nFreq"):
            print("\t\tNumber of calculated frequencies          : {:4.0f}".format(self.nFreq))
        if hasattr(self, "nQ"):
            print("\t\tNumber of calculated Q-points             : {:4.0f}".format(self.nQ))
    def print_ham(self, R, orb='all' ,imag=False, abc_to_cart=[[1,0,0], [0,1,0], [0,0,1]]):
        """
            Prints the Hamiltonian of the Wannier at a given R vectors, for chosen Wannier functions

            Parameters
            ----------
                R                  : list of 3-uples
                    The different R vectors
                orb                : list of string
                    The list of the names of the Wannier functions to include in the print (default is all)
                imag               : bool                   
                    Wether or not to print the imaginary part (default is False)
                abc_to_cart        : 2D list of dimensions 3x3
                    If you want to specify R in x,y,z and not in a1, a2, a3, this is the matrix that
                    transforms the vector in the a1, a2, a3 basis to the x, y, z basis
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("MODEL HAMILTONIAN"))
        print("="*TERMINAL_COLUMNS)
        for i in R:
            currR = np.matmul(np.linalg.inv(abc_to_cart), i)
            iR = np.where(np.sum(np.absolute(self.R-np.asarray(currR,dtype=int)), axis=1) == 0)[0][0]
            print('R = ({:+3.1f},{:+3.1f},{:+3.1f}) (in xyz) = ({:+1.0f},{:+1.0f},{:+1.0f}) (in abc)'.format(i[0], i[1], i[2], self.R[iR][0], self.R[iR][1], self.R[iR][2]))
            if orb == 'all':
                if imag:
                    print("\tREAL PART")
                print('\t{:10s}'.format(''),end='')
                for i in range(self.nW):
                    print("{:>10s}   ".format(self.basis[i]), end='')
                print()
                for i in range(self.nW):
                    print("\t{:10s}".format(self.basis[i]), end='')
                    for j in range(self.nW):
                        print("{:+10.3f}   ".format(self.ModelHamiltonian[iR,i,j].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:^10s}'.format(''),end='')
                    for i in range(self.nW):
                        print("{:>10s}   ".format(self.basis[i]), end='')
                    print()
                    for i in range(self.nW):
                        print("\t{:10s}".format(self.basis[i]), end='')
                        for j in range(self.nW):
                            print("{:+10.3f}   ".format(self.ModelHamiltonian[iR,i,j].imag), end='')
                        print()
            else:
                if imag:
                    print('\tREAL PART')
                print('\t{:10s}'.format(''),end='')
                for i in orb:
                    print("{:>10s}   ".format(i), end='')
                print()
                for i in orb:
                    a = self.basis.index(i)
                    print("\t{:^10s}".format(i), end='')
                    for j in orb:
                        b = self.basis.index(j)
                        print("{:+10.3f}   ".format(self.ModelHamiltonian[iR,a,b].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:10s}'.format(''),end='')
                    for i in orb:
                        print("{:>10s}   ".format(i), end='')
                    print()
                    for i in orb:
                        a = self.basis.index(i)
                        print("\t{:^10s}".format(i), end='')
                        for j in orb:
                            b = self.basis.index(j)
                            print("{:+10.3f}   ".format(self.ModelHamiltonian[iR,a,b].imag), end='')
                        print()
            print()
    def plot_hopping(self, ax,  hoppings, **kwargs):
        """
            Plots the hoppings between the Wanniers in a colormap

            Parameters
            ----------
                ax                  : list of matplotlib.pyplot.axes
                    The matplotlib ax to where the hoppings will be plotted
                hoppings            : list of tuples of ints
                    A list of tuples giving the indices of the w1 and w2 wannier between which
                    we are interested in the plotting 
                **kwargs
                    value_type      : "abs", "phase"
                        Wether the program will plot the absolute value of the hopping or leave the phase, default is abs
                    abc_to_cart     : 2D list of dimensions 3x3
                        If you want to R in x,y,z and not in a1, a2, a3, this is the matrix that
                        transforms the vector in the a1, a2, a3 basis to the x, y, z basis, default is identity
                    offset          : a list of 3 floats
                        If you want an offset in the position of the R vector, default is no offset
                    maxX            : int
                        The maximum value to plot along a1, default is nA[0]
                    maxY            : int
                        The maximum value to plot along a2, default is nA[1]
                    maxY            : int
                        The maximum value to plot along a3, default is nA[2]
                    ++ All the kwargs that go with a matplotlib.pyplot.pcolormesh

            Returns
            -------
                matplotlib.pyplot.pcolormesh 
                    Useful in order to add a colorbar to the plot

        """
        value_type = kwargs.pop("value_type", "abs")
        T = kwargs.pop("abc_to_cart", [[1,0,0], [0,1,0], [0,0,1]])
        offset = kwargs.pop("offset", [0.0, 0.0, 0.0])

        hoppings = [(self.basis.index(i[0]), self.basis.index(i[1])) for i in hoppings]

        T = np.array(T)

        offset = np.array(offset)

        maxX = kwargs.pop("maxX", self.nA[0])
        maxY = kwargs.pop("maxY", self.nA[1])
        maxZ = kwargs.pop("maxZ", self.nA[2])

        nX = 2*maxX + 1
        nY = 2*maxY + 1

        maxval = np.max(np.absolute(self.ModelHamiltonian.real))
        for i in range(len(hoppings)):
            o1 = hoppings[i][0]
            o2 = hoppings[i][1]
            t = []

            for iR in range(self.nR):
                currR = np.matmul(T.transpose(), self.R[iR]) - offset
                if not np.all(np.equal(np.mod(currR, 1), 0)):
                    continue

                if value_type == "abs":
                    if np.absolute(currR[0]) <= maxX and np.absolute(currR[1]) <= maxY and np.absolute(currR[2]) <= maxZ:
                        t.append([np.absolute(self.ModelHamiltonian[iR, o1, o2].real), 
                            currR[0], currR[1], currR[2]])
                elif value_type == "phase":
                    if np.absolute(currR[0]) <= maxX and np.absolute(currR[1]) <= maxY and np.absolute(currR[2]) <= maxZ:
                        t.append([self.ModelHamiltonian[iR, o1, o2].real, 
                            currR[0], currR[1], currR[2]])

            for ip in range(maxZ+1):
                def srt(a):
                    return (a[1],a[2])
                t = sorted(t, key=srt)
                t = np.array(t)

                cond = t[:,3] == ip

                X = t[cond][:,1]
                Y = t[cond][:,2]
                Z = t[cond][:,0]
                
                X = np.linspace(np.min(X), np.max(X), nX+1)
                Y = np.linspace(np.min(Y), np.max(Y), nY+1)
                Z = np.zeros( (nX, nY) , dtype=float)

                for it in t[cond]:
                    x = int(it[1])
                    y = int(it[2])
                    Z[x+maxX,y+maxY] = it[0]
               #    Z[-x+maxX, y+maxY] = it[0]
               #    Z[-x+maxX,-y+maxY] = it[0]
               #    Z[x+maxX,-y+maxY] = it[0]

                X, Y = np.meshgrid(X, Y)

                im = ax[ip,i].pcolormesh(X, Y, Z, **kwargs)

        return im
    def interpolate_bands(self, kpts, **kwargs):
        """
            Interpolates the bandstructure along a given k-path using
            the Wannier hamiltonian

            Parameters
            ----------
                kpts        : list of list of 3 floats
                    The high-symmetry k-points used for the interpolation
                **kwargs    
                    orb         : A list of int
                        The indices (starting at 0) of the Wanniers to include in the interpolation, default is all
                    fileName    : str
                        The name of a file to write the band energies, default is None
                    div         : int
                        The number of divisions between each high-symmetry k-point, default 30
                    showk       : bool
                        Whether or not to print all the k-points computed, default False

            Returns
            -------
                x           : np.array of floats, shape (nKpt)
                    The normalized coordinates of all the computed k-points
                bands       : np.array of, shape (nKpt, nOrb)
                    The energies of the bands at all k-points
        """
        orb = kwargs.pop('orb', range(self.nW))
        fileName = kwargs.pop('fileName', None)
        div = kwargs.pop('div', 30)
        showk = kwargs.pop("showk", False)
        nOrb = len(orb)
        kpts = np.array(kpts)

        #Â Generates all the k-points
        k = np.linspace((kpts[0,0], kpts[0,1], kpts[0,2]),
                (kpts[1,0], kpts[1,1], kpts[1,2]),div, endpoint=False)
        for i in range(1, len(kpts)-1):
            k = np.append(k, np.linspace((kpts[i,0], kpts[i,1], kpts[i,2]),
                (kpts[i+1,0], kpts[i+1,1], kpts[i+1,2]),div, endpoint=False), axis=0)
        k = np.append(k, [[kpts[-1,0], kpts[-1,1], kpts[-1,2]]], axis=0)
        nK = len(k)

        if showk:
            print("="*TERMINAL_COLUMNS)
            print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("BANDS INTERPOLATION"))
            print("="*TERMINAL_COLUMNS)
            print("\tk-points : ")
            nLine = len(k)//3+1 
            remin = len(k)%3
            for i in range(nLine):
                if i < nLine-remin-1:
                    print("\t{:3.0f} : {:+10.6f}  {:+10.6f}  {:+10.6f}  ||  {:3.0f} : {:+10.6f}  {:+10.6f}  {:+10.6f}  ||  {:3.0f} : {:+10.6f}  {:+10.6f}  {:+10.6f}".format(i+1,k[i,0], k[i,1], k[i,2],
                        i+1+nLine,k[i+nLine, 0],k[i+nLine, 1],k[i+nLine, 2],
                        i+1+2*nLine,k[i+2*nLine,0],k[i+2*nLine,1],k[i+2*nLine,2]))
                else:
                    print("\t{:3.0f} : {:+10.6f}  {:+10.6f}  {:+10.6f}  ||  {:3.0f} : {:+10.6f}  {:+10.6f}  {:+10.6f}  ||".format(i+1,k[i,0], k[i,1], k[i,2],
                        i+nLine+1,k[i+nLine-1, 0],k[i+nLine-1, 1],k[i+nLine-1, 2]))

        H = np.zeros((self.nR, nOrb, nOrb), dtype=complex)
        H = self.ModelHamiltonian[:,orb,:][:,:,orb]

        bands = np.zeros((nK, nOrb))

        newR = np.array([self.__search_R_min(i) for i in self.R])
        for ik in range(nK):
            Ht = H*self.W[:, None, None]
            # Compute the phase factor
            ph = np.exp(2j*np.pi*np.dot(newR, k[ik]))*self.W
            # Fourier transform the Hamiltonian in k space
            Hk = np.sum(ph[:,None, None] * Ht, axis=0)
            # Make Hk hermitian
            Hk = 1/2 * (Hk + np.conjugate(Hk.transpose()))
            eigenvals, eigenvec = np.linalg.eig(Hk)
            bands[ik, :] = sorted(eigenvals[:].real)
            if np.max(eigenvals[:].imag) > 1e-5:
                loc = np.unravel_index(eigenvals[:].imag.argmax(), eigenvals[:].imag.shape)[0]
                print("Imaginary part too high for band nÂ°{:2.0f} at k-point nÂ°{:3.0f}: {:16.10f}+i{:16.10f}".format(loc+1, ik+1, eigenvals[loc].real, eigenvals[loc].imag))

        k = np.matmul(k, self.ReciprocalLatticeVectors)
        x = np.linalg.norm( k[1:]-k[:-1], axis=1)
        x = np.cumsum(x)
        x = np.append([0.0], x) / x[-1]

        if fileName:
            with open(fileName, 'w') as f:
                f.write("#Wannier interpolated band\n#1:k, 2:Energy [eV]\n")
                s=1
                for iW in range(nOrb):
                    for iK in range(nK):
                        if s==1:
                            f.write("{:20.10f}  {:20.10f}\n".format(x[iK], bands[iK, iW]))
                        elif s== -1:
                            f.write("{:20.10f}  {:20.10f}\n".format(x[nK-iK-1], bands[nK-iK-1, iW]))
                    s *= -1
        return x, bands
    def print_W(self, R, orb='all' ,imag=False, abc_to_cart=[[1,0,0], [0,1,0], [0,0,1]]):
        """
            Prints the W matrix for given R vectors

            Parameters
            ----------
                R           : list of 3-uples
                    The list of all the R vectors to print
                orb         : list of str
                    The names of the Wannier to print, default is all
                imag        : bool
                    Whether or not to print the imaginary part, default is false
                abc_to_cart        : 2D list of dimensions 3x3
                    If you want to specify R in x,y,z and not in a1, a2, a3, this is the matrix that
                    transforms the vector in the a1, a2, a3 basis to the x, y, z basis
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("W MATRIX"))
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("FREQUENCY : {:10.6f} eV".format(self.calcW)))
        print("="*TERMINAL_COLUMNS)
        for i in R:
            currR = np.matmul(np.linalg.inv(abc_to_cart), i)
            iR = np.where(np.sum(np.absolute(self.R-np.asarray(currR,dtype=int)), axis=1) == 0)[0][0]
            print('R = ({:+3.1f},{:+3.1f},{:+3.1f}) (in xyz) = ({:+1.0f},{:+1.0f},{:+1.0f}) (in abc)'.format(i[0], i[1], i[2], self.R[iR][0], self.R[iR][1], self.R[iR][2]))
            if orb == 'all':
                if imag:
                    print("\tREAL PART")
                print('\t{:10s}'.format(''),end='')
                for i in range(self.nW):
                    print("{:>10s}   ".format(self.basis[i]), end='')
                print()
                for i in range(self.nW):
                    print("\t{:10s}".format(self.basis[i]), end='')
                    for j in range(self.nW):
                        print("{:+10.3f}   ".format(self.Wmat[iR,i,j].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:^10s}'.format(''),end='')
                    for i in range(self.nW):
                        print("{:>10s}   ".format(self.basis[i]), end='')
                    print()
                    for i in range(self.nW):
                        print("\t{:10s}".format(self.basis[i]), end='')
                        for j in range(self.nW):
                            print("{:+10.3f}   ".format(self.Wmat[iR,i,j].imag), end='')
                        print()
            else:
                if imag:
                    print('\tREAL PART')
                print('\t{:10s}'.format(''),end='')
                for i in orb:
                    print("{:>10s}   ".format(i), end='')
                print()
                for i in orb:
                    a = self.basis.index(i)
                    print("\t{:^10s}".format(i), end='')
                    for j in orb:
                        b = self.basis.index(j)
                        print("{:+10.3f}   ".format(self.Wmat[iR,a,b].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:10s}'.format(''),end='')
                    for i in orb:
                        print("{:>10s}   ".format(i), end='')
                    print()
                    for i in orb:
                        a = self.basis.index(i)
                        print("\t{:^10s}".format(i), end='')
                        for j in orb:
                            b = self.basis.index(j)
                            print("{:+10.3f}   ".format(self.Wmat[iR,a,b].imag), end='')
                        print()
            print()
    def print_J(self, R, orb='all' ,imag=False, abc_to_cart=[[1,0,0], [0,1,0], [0,0,1]]):
        """
            Prints the J matrix for given R vectors

            Parameters
            ----------
                R           : list of 3-uples
                    The list of all the R vectors to print
                orb         : list of str
                    The names of the Wannier to print, default is all
                imag        : bool
                    Whether or not to print the imaginary part, default is false
                abc_to_cart        : 2D list of dimensions 3x3
                    If you want to specify R in x,y,z and not in a1, a2, a3, this is the matrix that
                    transforms the vector in the a1, a2, a3 basis to the x, y, z basis
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("J MATRIX"))
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("FREQUENCY : {:10.6f} eV".format(self.calcW_j)))
        print("="*TERMINAL_COLUMNS)
        for i in R:
            currR = np.matmul(np.linalg.inv(abc_to_cart), i)
            iR = np.where(np.sum(np.absolute(self.JR-np.asarray(currR,dtype=int)), axis=1) == 0)[0][0]
            print('R = ({:+3.1f},{:+3.1f},{:+3.1f}) (in xyz) = ({:+1.0f},{:+1.0f},{:+1.0f}) (in abc)'.format(i[0], i[1], i[2], self.R[iR][0], self.R[iR][1], self.R[iR][2]))
            if orb == 'all':
                if imag:
                    print("\tREAL PART")
                print('\t{:10s}'.format(''),end='')
                for i in range(self.nW):
                    print("{:>10s}   ".format(self.basis[i]), end='')
                print()
                for i in range(self.nW):
                    print("\t{:10s}".format(self.basis[i]), end='')
                    for j in range(self.nW):
                        print("{:+10.3f}   ".format(self.Jmat[iR,i,j].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:^10s}'.format(''),end='')
                    for i in range(self.nW):
                        print("{:>10s}   ".format(self.basis[i]), end='')
                    print()
                    for i in range(self.nW):
                        print("\t{:10s}".format(self.basis[i]), end='')
                        for j in range(self.nW):
                            print("{:+10.3f}   ".format(self.Jmat[iR,i,j].imag), end='')
                        print()
            else:
                if imag:
                    print('\tREAL PART')
                print('\t{:10s}'.format(''),end='')
                for i in orb:
                    print("{:>10s}   ".format(i), end='')
                print()
                for i in orb:
                    a = self.basis.index(i)
                    print("\t{:^10s}".format(i), end='')
                    for j in orb:
                        b = self.basis.index(j)
                        print("{:+10.3f}   ".format(self.Jmat[iR,a,b].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:10s}'.format(''),end='')
                    for i in orb:
                        print("{:>10s}   ".format(i), end='')
                    print()
                    for i in orb:
                        a = self.basis.index(i)
                        print("\t{:^10s}".format(i), end='')
                        for j in orb:
                            b = self.basis.index(j)
                            print("{:+10.3f}   ".format(self.Jmat[iR,a,b].imag), end='')
                        print()
            print()
    def print_X(self, R, orb='all' ,imag=False, abc_to_cart=[[1,0,0], [0,1,0], [0,0,1]]):
        """
            Prints the X matrix for given R vectors

            Parameters
            ----------
                R           : list of 3-uples
                    The list of all the R vectors to print
                orb         : list of str
                    The names of the Wannier to print, default is all
                imag        : bool
                    Whether or not to print the imaginary part, default is false
                abc_to_cart        : 2D list of dimensions 3x3
                    If you want to specify R in x,y,z and not in a1, a2, a3, this is the matrix that
                    transforms the vector in the a1, a2, a3 basis to the x, y, z basis
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("X MATRIX"))
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("FREQUENCY : {:10.6f} eV".format(self.calcW_j)))
        print("="*TERMINAL_COLUMNS)
        for i in R:
            currR = np.matmul(np.linalg.inv(abc_to_cart), i)
            iR = np.where(np.sum(np.absolute(self.JR-np.asarray(currR,dtype=int)), axis=1) == 0)[0][0]
            print('R = ({:+3.1f},{:+3.1f},{:+3.1f}) (in xyz) = ({:+1.0f},{:+1.0f},{:+1.0f}) (in abc)'.format(i[0], i[1], i[2], self.R[iR][0], self.R[iR][1], self.R[iR][2]))
            if orb == 'all':
                if imag:
                    print("\tREAL PART")
                print('\t{:10s}'.format(''),end='')
                for i in range(self.nW):
                    print("{:>10s}   ".format(self.basis[i]), end='')
                print()
                for i in range(self.nW):
                    print("\t{:10s}".format(self.basis[i]), end='')
                    for j in range(self.nW):
                        print("{:+10.3f}   ".format(self.Xmat[iR,i,j].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:^10s}'.format(''),end='')
                    for i in range(self.nW):
                        print("{:>10s}   ".format(self.basis[i]), end='')
                    print()
                    for i in range(self.nW):
                        print("\t{:10s}".format(self.basis[i]), end='')
                        for j in range(self.nW):
                            print("{:+10.3f}   ".format(self.Xmat[iR,i,j].imag), end='')
                        print()
            else:
                if imag:
                    print('\tREAL PART')
                print('\t{:10s}'.format(''),end='')
                for i in orb:
                    print("{:>10s}   ".format(i), end='')
                print()
                for i in orb:
                    a = self.basis.index(i)
                    print("\t{:^10s}".format(i), end='')
                    for j in orb:
                        b = self.basis.index(j)
                        print("{:+10.3f}   ".format(self.Xmat[iR,a,b].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:10s}'.format(''),end='')
                    for i in orb:
                        print("{:>10s}   ".format(i), end='')
                    print()
                    for i in orb:
                        a = self.basis.index(i)
                        print("\t{:^10s}".format(i), end='')
                        for j in orb:
                            b = self.basis.index(j)
                            print("{:+10.3f}   ".format(self.Xmat[iR,a,b].imag), end='')
                        print()
            print()
    def print_V(self, R, orb='all' ,imag=False, abc_to_cart=[[1,0,0], [0,1,0], [0,0,1]]):
        """
            Prints the V matrix for given R vectors

            Parameters
            ----------
                R           : list of 3-uples
                    The list of all the R vectors to print
                orb         : list of str
                    The names of the Wannier to print, default is all
                imag        : bool
                    Whether or not to print the imaginary part, default is false
                abc_to_cart        : 2D list of dimensions 3x3
                    If you want to specify R in x,y,z and not in a1, a2, a3, this is the matrix that
                    transforms the vector in the a1, a2, a3 basis to the x, y, z basis
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("V MATRIX"))
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("FREQUENCY : {:10.6f} eV".format(self.calcW)))
        print("="*TERMINAL_COLUMNS)
        for i in R:
            currR = np.matmul(np.linalg.inv(abc_to_cart), i)
            iR = np.where(np.sum(np.absolute(self.R-np.asarray(currR,dtype=int)), axis=1) == 0)[0][0]
            print('R = ({:+3.1f},{:+3.1f},{:+3.1f}) (in xyz) = ({:+1.0f},{:+1.0f},{:+1.0f}) (in abc)'.format(i[0], i[1], i[2], self.R[iR][0], self.R[iR][1], self.R[iR][2]))
            if orb == 'all':
                if imag:
                    print("\tREAL PART")
                print('\t{:10s}'.format(''),end='')
                for i in range(self.nW):
                    print("{:>10s}   ".format(self.basis[i]), end='')
                print()
                for i in range(self.nW):
                    print("\t{:10s}".format(self.basis[i]), end='')
                    for j in range(self.nW):
                        print("{:+10.3f}   ".format(self.Vmat[iR,i,j].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:^10s}'.format(''),end='')
                    for i in range(self.nW):
                        print("{:>10s}   ".format(self.basis[i]), end='')
                    print()
                    for i in range(self.nW):
                        print("\t{:10s}".format(self.basis[i]), end='')
                        for j in range(self.nW):
                            print("{:+10.3f}   ".format(self.Vmat[iR,i,j].imag), end='')
                        print()
            else:
                if imag:
                    print('\tREAL PART')
                print('\t{:10s}'.format(''),end='')
                for i in orb:
                    print("{:>10s}   ".format(i), end='')
                print()
                for i in orb:
                    a = self.basis.index(i)
                    print("\t{:^10s}".format(i), end='')
                    for j in orb:
                        b = self.basis.index(j)
                        print("{:+10.3f}   ".format(self.Vmat[iR,a,b].real), end='')
                    print()
                if imag:
                    print()
                    print("\tIMAGINARY PART")
                    print('\t{:10s}'.format(''),end='')
                    for i in orb:
                        print("{:>10s}   ".format(i), end='')
                    print()
                    for i in orb:
                        a = self.basis.index(i)
                        print("\t{:^10s}".format(i), end='')
                        for j in orb:
                            b = self.basis.index(j)
                            print("{:+10.3f}   ".format(self.Vmat[iR,a,b].imag), end='')
                        print()
            print()
    def get_W(self, R, orb1, orb2, imag=False, abc_to_cart=[[1,0,0], [0,1,0], [0,0,1]]):
        """
            Returns the value of W at a given R vector between orb1 and orb2

            Parameters
            ----------
                R       : 3-uple
                    The R vector
                orb1    : str
                    Name of the first Wannier
                orb2    : str
                    Name of the second Wannier
                imag    : bool
                    Whether or not to return the imaginary part, default is False
                abc_to_cart        : 2D list of dimensions 3x3
                    If you want to specify R in x,y,z and not in a1, a2, a3, this is the matrix that
                    transforms the vector in the a1, a2, a3 basis to the x, y, z basis


            Return
            ------
                The value of W at the chosen point
        """
        if not hasattr(self, "Wmat"):
            print("No W matrix set yet")
            exit()

        R = np.matmul(np.linalg.inv(abc_to_cart), R)
        iR = np.where(np.sum(np.absolute(self.R - np.asarray(R, dtype=int)), axis=1) == 0)[0][0]
        iA = self.invBasis[orb1]-1
        iB = self.invBasis[orb2]-1

        if imag:
            return self.Wmat[iR, iA, iB]
        else:
            return self.Wmat[iR, iA, iB].real
    def get_spread(self, orb):
        """
            Returns the spread of a given Wannier function

            Parameters
            ----------
                orb : str
                    The name of the Wannier function

            Returns
            -------
                The spread of the Wannier function
        """
        iA = self.invBasis[orb]-1
        return self.spread[iA] 
    def __search_R_min(self, R):
        """
            Searches the R corresponding to the minimum distance

            Parameters
            ----------
                R : 3-uple
                    The R-vector
        """
        dR = np.linalg.norm(R)
        n = np.arange(-3,4)
        l = np.arange(-3,4)
        m = np.arange(-3,4)
        n, l, m = np.meshgrid(n, l, m)

        R_buffer = np.zeros( (7, 7, 7, 3), dtype=float)

        R_buffer[:,:,:,0] = R[0] + n * self.nkb[0]
        R_buffer[:,:,:,1] = R[1] + l * self.nkb[1]
        R_buffer[:,:,:,2] = R[2] + m * self.nkb[2]

        R_buffer = R_buffer.reshape( (343, 3) ).transpose()
        R_buffer = np.matmul( self.LatticeVectors.transpose(), R_buffer )

        R_buffer = np.linalg.norm(R_buffer, axis=0)

        Rm = list(np.unravel_index( R_buffer.argmin() , (7,7,7) ))
        R_min = np.zeros(3, dtype=int)
        R_min[0] = R[0] + ( n[Rm[0], Rm[1], Rm[2]] ) * self.nkb[0]
        R_min[1] = R[1] + ( l[Rm[0], Rm[1], Rm[2]] ) * self.nkb[1]
        R_min[2] = R[2] + ( m[Rm[0], Rm[1], Rm[2]] ) * self.nkb[2]

        return R_min
