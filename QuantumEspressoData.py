import os
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import scipy.optimize

try:
    try:
        shell = get_ipython().__class__.__name__
        # Check for a jupyter notebook
        if shell == 'ZMQInteractiveShell':
            TERMINAL_COLUMNS =  114
        else:
            # Nice formatting
            TERMINAL_COLUMNS = min(150, os.get_terminal_size().columns)
    except NameError:
        TERMINAL_COLUMNS = min(150, os.get_terminal_size().columns)
except OSError :
    TERMINAL_COLUMNS = 150

class QuantumEspressoData:
    """
        A class that stores and manipulates the output data generated by QuantumEspresso

        Attributes
        ----------
            maxproj         : int
                The maximum number of projections
            SymKLabel       : list of str
                The name of the high-symmetry k-points
            nAtom           : int
                The number of atoms in the system
            AtomPos         : np.array of float, shape (nAtom, 3)
                The positions of the atoms
            AtomName        : np.chararray , shape (nAtom)
                The names of the atoms
            fermi           : float
                The Fermi energy
            TotEnergy       : float
                The total energy
            nSymK           : int
                The number of high-symmetry k-points
            symK            : list of int, shape (nSymK)
                The indices of the high symmetry k-points
            nbnd          : int
                The number of bands
            nk            : int
                The number of k-points
            bands         : np.array of floats, shape (nbnd, nk)
                The bands energies
            kpt           : np.array of floats, shape (nk, 3)
                The coordinates of the k-points
            k             : np.array of floats, shape(nk)
                The normalized positions of the k-points
            label         : list of str
                The labels of the high-symmetry points
            tick          : list of int
                The indices for the labels

          ++IF dos.dat FILE  
            fermiDOS        : float
                The Fermi energy in the DOS output
            DOS           : np.array of floats
                The density of states

          ++IF *dat.projwfc_up file 
            ProjBand      : list of floats , shape (nbnd, nk, nAtom, maxproj)
                The projections of the wavefunction on the different bands
            ProjList      : dict   { str : { str : tuple of int } }
            nproj         : int 
                The number of projections

          ++IF pdos.dat.pdos* files
            ProjDOSE      : np.array of floats
                The energies of the projected DOS
            ProjDOS       : np.array of floats (number_of_energies, nAtom, maxproj)
                The value of the projected dos

        Methods
        -------
            __init__(baseDir, **kwargs)
                Initializes the class
            print_parameters()
                Prints the parameters and results of the computation
            plot__bands(ax, **kwargs)
                Plots the QuantumEspresso bands
            plot__proj(ax, t, **kwargs)
                Plots the fatbands
            plot__dos(ax, **kwargs)
                Plots the density of states
            plot__pdos(ax, t, **kwargs)
                Plots the projected density of states
            get__band_from_proj(t, **kwargs)
                Returns a band using corresponding to a projection character
            fit_bands(fun, y, nArg, argName)
                Fits a band y using function fun
    """
    def __init__(self, baseDir, **kwargs):
        """
            Parameters
            ----------
            baseDir         : str
                The name of the basis directory in which the QuantumEspresso output files are
                Format of the file names expected :
                    SCF         : *.scf.out
                    DOS         : *dos.dat
                    PLOTBAND    : *plot.out
                    BANDS       : *band.dat
                    PROJWFC     : *dat.projwfc_up  && pdos.dat.pdos*
            **kwargs
                maxproj     : int
                    The maximum number of projections
                SymKLabel   : list of str
                    The names of the different high-symmetry k-points in the band path
        """
        self.maxproj = kwargs.pop("maxproj", 20)
        self.SymKLabel = kwargs.pop("symklabel", [])

        # Finding the Quantum Espresso SCF file
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('.scf.out')]

        if len(f) == 0:
            print("No QuantumEspresso SCF output file found")
            exit()
        if len(f) > 1:
            print("More than one QuantumEspresso SCF output file found :")
            for i in f:
                print(i)
            exit()

        # Reading the data of the .scf.out file
        with open(f[0]) as f:
            data = f.readlines()
            for i in range(len(data)):
                if "number of atoms/cell" in data[i]:
                    self.nAtom = int(data[i].split()[4])
                    self.AtomPos = np.zeros((self.nAtom, 3), dtype=float)
                    self.AtomName = np.chararray(self.nAtom, itemsize=2)
                elif "Crystallographic axes" in data[i]:
                    for j in range(self.nAtom):
                        self.AtomName[j] = data[i+3+j].split()[1]
                        self.AtomPos[j,0] = float(data[i+3+j].split()[6])
                        self.AtomPos[j,1] = float(data[i+3+j].split()[7])
                        self.AtomPos[j,2] = float(data[i+3+j].split()[8])
                elif "the Fermi energy is" in data[i]:
                    self.fermi = float(data[i].split()[4])
                elif "!" in data[i]:
                    self.TotEnergy = float(data[i].split()[4])


        # Finding the Quantum Espresso dos file
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('dos.dat')]
        if len(f) > 1:
            print("More than one QuantumEspresso dos.dat file found :")
            for i in f:
                print(f)
            exit()
        elif len(f) == 1:
            with open(f[0]) as f:
                data = f.readlines()
                head = data.pop(0).split()
                self.fermiDOS = float(head[-2])

                data = [i.split() for i in data]
                self.DOS = np.asarray(data, dtype = float)

        # Finding the Quantum Espresso band.plot output file
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('.plot.out')]
        if len(f) == 0:
            print("No QuantumEspresso plotbands.x output file found")
            exit()
        elif(len(f) > 1):
            print("More than one QuantumEspresso plotbands.x output file found")
        with open(f[0]) as f:
            symk = []
            data = f.readlines()
            for i in data:
                if 'high-symmetry point:' in i:
                    l = i.split()
                    k = []
                    for j in range(2, 5):
                        if len(l[j].split('-')) > 1:
                            for m in l[j].split('-'):
                                if m == '':
                                    continue
                                else:
                                    k.append( -float(m) )
                        else:
                            k.append(float(l[j]))

                        if len(k) == 3:
                            break
                    symk.append(k)
            self.nSymK = len(symk)
            self.symK = np.array(symk)
            if self.nSymK != len(self.SymKLabel):
                print("Specified a different number of label than the number of high symmetry k-points")
                print("Labels : ")
                for i in self.SymKLabel:
                    print(i)
                print("High-symmetry points :")
                for i in self.symK:
                    print(i)
                exit()

        # Finding the Quantum Espresso band file
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('band.dat')]
        if len(f) == 0:
            print("No Quantum Espresso band.dat file found")
            exit()
        elif(len(f)) > 1:
            print("More than one QuantumEspresso band.dat file found :")
            for i in f:
                print(i)
            exit()
        with open(f[0]) as f:
            data = f.readlines()

            self.nbnd = int(data[0].split()[2][:-1])
            self.nk = int(data[0].split()[4])

            self.bands = np.zeros((self.nbnd, self.nk), dtype=float)
            self.kpt = np.zeros((self.nk, 3), dtype=float)
            self.k = np.zeros(self.nk, dtype=float)
            self.label = []
            self.tick = []

            nL = self.nbnd // 10 +  ( (self.nbnd % 10) != 0 ) * 1

            for i in range(self.nk):
                j = 1 + i * (nL + 1)
                k = np.asarray( data[j].split(), dtype=float )
                self.kpt[i,:] = k[:]

                if i > 0:
                    self.k[i] = self.k[i-1] + np.linalg.norm( self.kpt[i,:]-self.kpt[i-1,:])
                m = np.where( np.linalg.norm(self.symK - [k[0], k[1], k[2]] , axis=1) < 1e-3)[0]
                if(len(m) > 0):
                    self.tick.append(i)
                    self.label.append(self.SymKLabel[m[0]])

                for k in range(nL):
                    l = np.asarray(data[j+k+1].split(), dtype=float)
                    if k != nL-1:
                        self.bands[10*k:10*(k+1), i] = l[:]
                    else:
                        self.bands[10*k:, i] = l[:]
            self.k /= self.k[-1]
        # Finding the projwfc Quantum Espresso file 
        f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                for f in files if f.endswith('dat.projwfc_up')]
        if len(f) > 1:
            print("More than one QuantumESpresso projwfc file found")
            for i in f:
                print(i)
            exit()
        elif len(f) == 1:
            self.nproj = 0
            with open(f[0]) as f:
                data = f.readlines()
                self.ProjBand = np.zeros((self.nbnd, self.nk, self.nAtom, self.maxproj), float)
                self.ProjList = {}
                start = 0
                SO = False
                while (data[start]+'.').split()[0] not in ['F', 'T']:
                    start += 1
                if (data[start]+'.').split()[0] == 'T':
                    SO = True
                start += 1
                oldatm = 0
                ip = 0

                i = start

                while i < len(data):
                    head = data[i].split()
                    ia = int(head[1])-1
                    atm = str(ia+1)+head[2]
                    prj = head[3]
                    if not SO:
                        l = int(head[5])
                        m = int(head[6])
                        if l==0:
                            m = ""
                        elif l==1:
                            if m == 1:
                                m = "z"
                            elif m == 2:
                                m = "x"
                            elif m == 3:
                                m = "y"
                        elif l==2:
                            if m == 1:
                                m = "z2"
                            elif m == 2:
                                m = "xz"
                            elif m == 3:
                                m = "yz"
                            elif m == 4:
                                m = "x2-y2"
                            elif m == 5:
                                m = "xy"
                        else:
                            m = str(m)
                    else:
                        l   = int(head[5])
                        j   = float(head[6])
                        m_j = float(head[7])
                        m = "_j{:3.1f}_{:+4.1f}".format(j, m_j)
                    if oldatm != ia:
                        ip = 0
                        oldatm = ia
                    prj = prj.lower() + m
                    self.nproj += 1
                    if atm not in self.ProjList:
                        self.ProjList[atm] = {prj:(ia, ip)}
                    else:
                        self.ProjList[atm][prj] = (ia, ip)
                    for ik in range(self.nk):
                        for ib in range(self.nbnd):
                            i += 1
                            line = data[i].split()
                            self.ProjBand[ib, ik, ia, ip] = float(line[2])
                    ip += 1
                    i += 1
        
            # Finding the pdos Quantum Espresso files
            f = [os.path.join(root, f) for root, _, files in os.walk(baseDir)
                    for f in files if f.startswith('pdos.dat.pdos')]
            if len(f) == 0:
                print("No pdos file found")
                exit()
            # Get the number of energies
            with open(f[0]) as g:
                data = g.readlines()
                nEner = len(data)-1
                self.ProjDOSE = np.zeros(nEner, dtype=float)
                for i in range(1,len(data)):
                    self.ProjDOSE[i-1] = float(data[i].split()[0])
            self.ProjDOS = np.zeros((nEner, self.nAtom, self.maxproj), dtype=float)

            ldic = {'s':0, 'p':1, 'd':2}
            mlist = [[''],['z','x','y'],['z2', 'xz', 'yz', 'x2-y2', 'xy']]
            for i in self.ProjList:
                nP = 0
                cL = ''
                atmNumber = i.rstrip('aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTvVuUvVwWxXyYzZ')
                atmName = i[len(atmNumber):]
                for j in self.ProjList[i]:
                    if not SO:
                        l = j[:2]
                    else:
                        l = j[:7]
                    if l != cL:
                        cL = l
                        nP += 1
                        b = baseDir+"pdos.dat.pdos_atm#" + atmNumber + "(" + atmName + ")_wfc#" + str(nP) + "(" + cL[1:] + ")"

                        if not SO:
                            nM = 2*ldic[cL[1]] + 1
                        else:
                            jeff = float( j.split('_')[1][1:] )
                            nM = int( 2 * jeff + 1 )

                        if b in f:
                            with open(b) as g:
                                data = g.readlines()
                                data.pop(0)
                                data = [i.split() for i in data]
                                data = np.asarray(data, dtype=float)
                                data = data[:,2:]

                                for k in range(nM):
                                    p = self.ProjList[i][j]
                                    self.ProjDOS[:,p[0],p[1]] = data[:,k]
                        else:
                            print("The projected dos file does not exist : ", b)
    def print_parameters(self):
        """
            Prints the parameters of the QuantumEspresso calculations and some computed results
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("PARAMETERS OF THE QUANTUM ESPRESSO CALCULATION"))
        print("="*TERMINAL_COLUMNS)

        print("\tSCF parameters : ")
        print("\t\tNumber of atoms                          : {:3.0f}".format(self.nAtom))
        print("\t\tAtom positions (fractionnal coordinates) :")
        for i in range(self.nAtom):
            print("\t\t\t{:2s}   {:16.10f}   {:16.10f}   {:16.10f}".format(self.AtomName[i].decode("utf-8"), self.AtomPos[i,0], self.AtomPos[i,1], self.AtomPos[i,2]))
        print("\t\tTotal energy (Ry)                        : {:16.10f}".format(self.TotEnergy))
        print("\t\tFermi energy (eV)                        : {:16.10f}".format(self.fermi))
        print("\tBANDS parameters : ")
        print("\t\tNumber of bands                          : {:3.0f}".format(self.nbnd))
        print("\t\tNumber of k-points                       : {:3.0f}".format(self.nk))
        print("\t\tHigh symmetry k-points                   :")
        for i in range(self.nSymK):
            print("\t\t\t{:20s} : {:+6.3f}   {:+6.3f}   {:+6.3f}".format(self.SymKLabel[i],self.symK[i,0], self.symK[i,1], self.symK[i,2]))
        if hasattr(self, 'fermiDOS'):
            print("\tDOS parameters : ")
            print("\t\tFermi energy (eV)                        : {:16.10f}".format(self.fermiDOS))
            print("\t\tDelta energy (eV)                        : {:16.10f}".format(self.DOS[1,0]-self.DOS[0,0]))
        if hasattr(self, 'ProjList'):
            print("="*TERMINAL_COLUMNS)
            print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("PROJECTION LIST"))
            print("="*TERMINAL_COLUMNS)
            for a in self.ProjList.keys():
                print("\t{:3s} : ".format(a), end="")
                tp = ''
                brk = TERMINAL_COLUMNS - 14
                for p in self.ProjList[a].keys():
                    if len(tp.split('\n')[-1])+15 > brk:
                            tp += "\n\t      "
                    tp += "{:15s}".format(p)
                print(tp)
    def plot_bands(self, ax, **kwargs):
        """
            Plots the QuantumEspresso bands in the specified axis

            Parameters
            ----------
                ax : matplotlib.pyplot.axes
                    The ax where the plot will be
                **kwargs
                    shift_fermi_energy : bool
                        Whether or not shift the fermi energy to 0, default is True
                    no_special_kpt     : bool
                        Wheter or not to remove all high-symmetry k-points from legend, default is False
                    ++All the ax.plot possible kwargs
                    
        """
        sf = kwargs.pop('shift_fermi_energy', True)
        ns = kwargs.pop('no_special_kpt', False)
        for ib in range(self.nbnd):
            ax.plot(self.k, self.bands[ib,:]-sf*self.fermi,zorder=3, **kwargs)
        if not sf:
            ax.axhline(y=self.fermi, color='black', linestyle="--", zorder=3)
        ax.set_xticks([self.k[i] for i in self.tick])
        ax.set_xticklabels(self.label)
        ax.set_xlim(0, self.k[-1])
    def plot_proj(self, ax, t,**kwargs):
        """
            Plots the QuantumEspresso fatbands

            Parameters
            ----------
                ax : matplotlib.pyplot.axes
                    The ax where the plot will be
                t  : str the specification of the coefficients to take 
                        Atom/Projections
                     To add some atoms or projections, add ^
                        atom1^atom2/5dxy^5dx2-y2  will add the 5dxy and 5dx2-y2 orbitals on atom1 and atom2
                **kwargs
                    shift_fermi_energy : bool
                        Whether or not shift the fermi energy to 0, default is True
                    coef               : float
                        The coefficient to broaden / shrink the fatbands, default is 0.2
                    ++ All the kwargs of fill_between
        """
        sf = kwargs.pop('shift_fermi_energy', True)
        coef = kwargs.pop('coef', 0.2)
        if not hasattr(self, 'ProjList'):
            print('No projection list set yet')
        t = t.split('/')
        # Full atom
        if len(t) == 1:
            t = t[0].split('^')
            ia = 0
            ip = []
            for it in t:
                for p in self.ProjList[it]:
                    ia = self.ProjList[it][p][0]
                    ip.append(self.ProjList[it][p][1])
        elif len(t) == 2:
            ia = 0
            ip = []
            t[0] = t[0].split('^')
            t[1] = t[1].split('^')
            for it0 in t[0]:
                for p in self.ProjList[it0]:
                    ia = self.ProjList[it0][p][0]
                    for it in t[1]:
                        if it in p:
                            ip.append(self.ProjList[it0][p][1])
        bnd = np.sum(self.ProjBand[:,:,ia,ip], axis=2)
        ym = self.bands[:,:] - self.fermi*sf - coef * bnd 
        yp = self.bands[:,:] - self.fermi*sf + coef * bnd 
        for ib in range(self.nbnd):
            cond = np.absolute(ym[ib,:]-yp[ib,:]) > 0.01
            ax.fill_between(self.k, ym[ib,:], yp[ib,:], where=cond, zorder=3, **kwargs)
    def plot_dos(self, ax, **kwargs):
        """
            Plots the QuantumEspresso density of states

            Parameters
            ----------
                ax : matplotlib.pyplot.axes
                    The ax where the plot will be
                **kwargs
                    shift_fermi_energy : bool
                        Whether or not shift the fermi energy to 0, default is True
                    ++ All the kwargs of plot
        """
        if not hasattr(self, 'DOS'):
            print("No DOS set yet")
            exit()
        sf = kwargs.pop('shift_fermi_energy', True)
        ax.plot(self.DOS[:,1], self.DOS[:,0] - sf*self.fermi, zorder=3, **kwargs)
    def plot_pdos(self, ax, t, **kwargs):
        """
            Plots the QuantumEspresso projected density of states

            Parameters
            ----------
                ax : matplotlib.pyplot.axes
                    The ax where the plot will be
                t  : str the specification of the coefficients to take 
                        Atom/Projections
                     To add some atoms or projections, add ^
                        atom1^atom2/5dxy^5dx2-y2  will add the 5dxy and 5dx2-y2 orbitals on atom1 and atom2
                **kwargs
                    shift_fermi_energy : bool
                        Whether or not shift the fermi energy to 0, default is True
                    ++ All the kwargs of plot
        """
        sf = kwargs.pop('shift_fermi_energy', True)
        if not hasattr(self, 'ProjList'):
            print('No projection list set yet')
            exit()
        t = t.split('/')
        # Full atom
        if len(t) == 1:
            t = t[0].split('^')
            ia = 0
            ip = []
            for it in t:
                for p in self.ProjList[it]:
                    ia = self.ProjList[it][p][0]
                    ip.append(self.ProjList[it][p][1])
        elif len(t) == 2:
            ia = 0
            ip = []
            t[0] = t[0].split('^')
            t[1] = t[1].split('^')
            for it0 in t[0]:
                for p in self.ProjList[it0]:
                    ia = self.ProjList[it0][p][0]
                    for it in t[1]:
                        if it in p:
                            ip.append(self.ProjList[it0][p][1])
        dos = np.sum(self.ProjDOS[:,ia, ip], axis=1)
        ax.plot(dos, self.ProjDOSE, **kwargs)
    def get_band_from_proj(self, t, **kwargs):
        """
            Returns the band following the maximum projection on t

            Parameters
            ----------
                t  : str the specification of the coefficients to take 
                        Atom/Projections
                     To add some atoms or projections, add ^
                        atom1^atom2/5dxy^5dx2-y2  will add the 5dxy and 5dx2-y2 orbitals on atom1 and atom2
                **kwargs:
                    minmax : list of float
                        The list of separations (between 0 and 1) for the min/max specifications. Default [1.0]
                    minE   : list of float
                        The minimum energy of the window for search for all minmax sets, default minimum energy of all bands
                    maxE   : list of float
                        The maximum energy of the window for search for all minmax sets, default minimum energy of all bands
                    offset : int
                        The offset (in number of bands). If 1, it will pick the second band with the most t character. Default 0

            Returns
            -------
                np.array of floats, the extracted band
        """
        bnd = []
        if not hasattr(self, "bands"):
            print("No  bands set yet")
            exit()
        minmax      = kwargs.pop("minmax", [1.0])
        minEnergies = kwargs.pop("minE",[np.min(self.bands)])
        maxEnergies = kwargs.pop("maxE",[np.max(self.bands)])
        offset = kwargs.pop("offset", 0)

        if not hasattr(self, "ProjList"):
            print("No projection list set yet")
            exit()
        t = t.split('/')

        if len(t)==1:
            t = t[0].split('^')
            ip = []
            for it in t:
                for p in self.ProjList[it]:
                    ip.append(self.ProjList[it][p])
        elif len(t) == 2:
            ip = []
            t[0] = t[0].split('^')
            t[1] = t[1].split('^')
            for it0 in t[0]:
                for p in self.ProjList[it0]:
                    for it in t[1]:
                        if it in p:
                            ip.append(self.ProjList[it0][p])

        sumProj = np.zeros((self.nk, self.nbnd), dtype=float)
        for ik in range(self.nk):
            for ib in range(self.nbnd):
                for i in ip:
                    sumProj[ik, ib] += self.ProjBand[ib, ik, i[0], i[1]]

        iener = 0
        maxEnergy = maxEnergies[iener]
        minEnergy = minEnergies[iener]
        for ik in range(self.nk):
            am = np.flip(np.argsort(sumProj[ik, :]))
            offdone = 0
            if self.k[ik] > minmax[iener]:
                iener += 1
                maxEnergy = maxEnergies[iener]
                minEnergy = minEnergies[iener]
            for ib in am:
                if self.bands[ib,ik] < maxEnergy and self.bands[ib,ik] > minEnergy :
                    if offdone == offset :
                        bnd.append(self.bands[ib,ik])
                        break
                    else:
                        offdone += 1
                if ib == am[-1]:
                    print("No projection found with an offset of {:2.0f} at k-point n°{:3.0f}".format(offset, ik))
                    bnd.append(np.nan)


        return np.array(bnd)
    def fit_bands(self, fun, y, nArg, argName):
        """
            Fits a given band 'y' with the function 'fun' adjusting parameters 'argName'

            Parameters
            ----------
                fun  : function
                    The function that the fit routine will use
                y    : np.array of floats
                    The energies of the band to fit
                nArg : int
                    The number of arguments for the fit
                argName : list of str
                    The list containing the names of the arguments

            Returns
            -------
                list : The list containing the parameters, in the order specified in argName
        """
        print("="*TERMINAL_COLUMNS)
        print(("{:^"+str(TERMINAL_COLUMNS)+"s}").format("FIT OF "+fun.__name__))
        print("="*TERMINAL_COLUMNS)
        p0 = np.ones(nArg, dtype=float)
        if len(y) % self.nk != 0:
            print("The size of y is not a multiple of the number of k-points")
            exit()
        nrep = len(y) // self.nk
        p, c = scipy.optimize.curve_fit(fun, np.tile(self.kpt, (nrep,1)) , y, p0=p0)
        nLines = nArg // 2 + 1
        remin   = nArg % 2

        dParam = {}
        for i in range(nArg):
            dParam[argName[i]] = p[i]

        print("\tOptimal parameters : ")
        for i in range(nLines):
            if i < nLines - remin :
                print("\t\t{:5s} : {:+14.10f} +/- {:+14.10f}  ||  {:5s} : {:+14.10f} +/- {:+14.10f}".format(
                    argName[i], p[i], c[i,i]**0.5, argName[i+nLines], p[i+nLines], c[i+nLines,i+nLines]**0.5))
            else:
                print("\t\t{:5s} : {:+14.10f} +/- {:+14.10f}  ||".format(
                    argName[i], p[i], c[i,i]**0.5))

        p = list(p)
        p.insert(0, np.tile( self.kpt , (nrep, 1) ))
        p = tuple(p)
        ymod = fun(*p)

        RMSD = np.sqrt( np.sum( (ymod-y)**2 )  / ( len(y) ) )

        print("\tFit RMSD : {:10.6f}".format(RMSD))

        return dParam
